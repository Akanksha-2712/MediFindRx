-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Create profiles table (linked to auth.users)
-- Create profiles table (linked to auth.users)
create table if not exists profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  name text,
  role text check (role in ('customer', 'pharmacy', 'admin', 'hospital')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create drugs table
-- Create drugs table
create table if not exists drugs (
  id bigint generated by default as identity primary key,
  name text not null,
  dosage text,
  type text,
  price numeric,
  description text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create pharmacies table
-- Create pharmacies table
create table if not exists pharmacies (
  id bigint generated by default as identity primary key,
  name text not null,
  address text,
  phone text,
  rating numeric default 0,
  owner_id uuid references auth.users, -- Link to a pharmacy user if needed
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create inventory table
-- Create inventory table
create table if not exists inventory (
  id bigint generated by default as identity primary key,
  pharmacy_id bigint references pharmacies(id) on delete cascade,
  drug_id bigint references drugs(id) on delete cascade,
  stock integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(pharmacy_id, drug_id)
);

-- Create reservations table
-- Create reservations table
create table if not exists reservations (
  id bigint generated by default as identity primary key,
  pharmacy_id bigint references pharmacies(id),
  drug_id bigint references drugs(id),
  user_id uuid references auth.users,
  customer_name text,
  otp text,
  status text default 'pending', -- pending, completed, cancelled
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Insert initial Mock Data for Drugs
-- Insert initial Mock Data for Drugs
insert into drugs (name, dosage, type, price, description) values
('Amoxicillin', '500mg', 'Antibiotic', 15.00, 'Used to treat bacterial infections.'),
('Lisinopril', '10mg', 'Blood Pressure', 10.00, 'Used to treat high blood pressure.'),
('Metformin', '500mg', 'Diabetes', 8.00, 'Used to treat type 2 diabetes.'),
('Atorvastatin', '20mg', 'Cholesterol', 20.00, 'Used to lower cholesterol.'),
('Ibuprofen', '200mg', 'Pain Reliever', 5.00, 'Used to reduce fever and treat pain or inflammation.')
ON CONFLICT DO NOTHING;

-- Insert initial Mock Data for Pharmacies
-- Insert initial Mock Data for Pharmacies
insert into pharmacies (name, address, phone) values
('HealthPlus Pharmacy', '123 Main St, New York, NY', '212-555-0123'),
('City Care Chemist', '456 Broadway, New York, NY', '212-555-0456'),
('MediQuick Rx', '789 5th Ave, New York, NY', '212-555-0789')
ON CONFLICT DO NOTHING;

-- Insert initial Inventory
-- (Legacy hardcoded inserts removed to prevent FK errors)

-- Set up Row Level Security (RLS) - For demo purposes, we will allow public access to read/write
-- In a real app, you should restrict this!
alter table profiles enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON profiles;
    CREATE POLICY "Public profiles are viewable by everyone" ON profiles FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Users can insert their own profile" ON profiles;
    CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
    CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
END $$;

alter table drugs enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Drugs are viewable by everyone" ON drugs;
    CREATE POLICY "Drugs are viewable by everyone" ON drugs FOR SELECT USING (true);
END $$;

alter table pharmacies enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Pharmacies are viewable by everyone" ON pharmacies;
    CREATE POLICY "Pharmacies are viewable by everyone" ON pharmacies FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Pharmacies can be created by pharmacy role" ON pharmacies;
    CREATE POLICY "Pharmacies can be created by pharmacy role" ON pharmacies FOR INSERT WITH CHECK (true); 
END $$;

alter table inventory enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Inventory is viewable by everyone" ON inventory;
    CREATE POLICY "Inventory is viewable by everyone" ON inventory FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Inventory can be updated by everyone (demo)" ON inventory;
    CREATE POLICY "Inventory can be updated by everyone (demo)" ON inventory FOR UPDATE USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Inventory can be inserted by everyone (demo)" ON inventory;
    CREATE POLICY "Inventory can be inserted by everyone (demo)" ON inventory FOR INSERT WITH CHECK (true);
END $$;

alter table reservations enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Reservations are viewable by everyone (demo)" ON reservations;
    CREATE POLICY "Reservations are viewable by everyone (demo)" ON reservations FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Reservations can be inserted by everyone" ON reservations;
    CREATE POLICY "Reservations can be inserted by everyone" ON reservations FOR INSERT WITH CHECK (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Reservations can be updated by everyone" ON reservations;
    CREATE POLICY "Reservations can be updated by everyone" ON reservations FOR UPDATE USING (true);
END $$;

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger 
language plpgsql 
security definer
set search_path = public, pg_temp, pg_catalog
as $$
begin
  insert into public.profiles (id, email, name, role)
  values (new.id, new.email, new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'role');
  
  -- Automatically create pharmacy record if role is pharmacy
  if (new.raw_user_meta_data->>'role' = 'pharmacy') then
    insert into public.pharmacies (name, owner_id, address, phone)
    values (new.raw_user_meta_data->>'name', new.id, 'Pending Address Update', 'Pending Phone');
  end if;

  return new;
end;
$$;

-- Create hospitals table
-- Create hospitals table
create table if not exists hospitals (
  id uuid references auth.users on delete cascade not null primary key,
  name text not null,
  address text,
  phone text,
  beds_total integer default 20,
  beds_occupied integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create hospital appointments table
-- Create hospital appointments table
create table if not exists hospital_appointments (
  id bigint generated by default as identity primary key,
  hospital_id uuid references hospitals(id) on delete cascade,
  patient_name text not null,
  scheduled_time timestamp with time zone not null,
  status text default 'scheduled', -- scheduled, completed, cancelled
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for Hospitals
alter table hospitals enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Hospitals are viewable by everyone" ON hospitals;
    CREATE POLICY "Hospitals are viewable by everyone" ON hospitals FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Hospitals can be updated by owner" ON hospitals;
    CREATE POLICY "Hospitals can be updated by owner" ON hospitals FOR UPDATE USING (auth.uid() = id);
END $$;

-- RLS for Appointments
alter table hospital_appointments enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Appointments viewable by hospital owner" ON hospital_appointments;
    CREATE POLICY "Appointments viewable by hospital owner" ON hospital_appointments FOR SELECT USING (auth.uid() = hospital_id);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Appointments insertable by hospital owner" ON hospital_appointments;
    CREATE POLICY "Appointments insertable by hospital owner" ON hospital_appointments FOR INSERT WITH CHECK (auth.uid() = hospital_id);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Appointments updatable by hospital owner" ON hospital_appointments;
    CREATE POLICY "Appointments updatable by hospital owner" ON hospital_appointments FOR UPDATE USING (auth.uid() = hospital_id);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Appointments deletable by hospital owner" ON hospital_appointments;
    CREATE POLICY "Appointments deletable by hospital owner" ON hospital_appointments FOR DELETE USING (auth.uid() = hospital_id);
END $$;

-- Update handle_new_user to create hospital record
create or replace function public.handle_new_user()
returns trigger 
language plpgsql 
security definer
set search_path = public, pg_temp, pg_catalog
as $$
begin
  insert into public.profiles (id, email, name, role)
  values (new.id, new.email, new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'role');
  
  -- Automatically create pharmacy record if role is pharmacy
  if (new.raw_user_meta_data->>'role' = 'pharmacy') then
    insert into public.pharmacies (name, owner_id, address, phone)
    values (new.raw_user_meta_data->>'name', new.id, 'Pending Address Update', 'Pending Phone');

    -- AUTOMATION: Assign 100 stock of EVERY drug to the new pharmacy
    insert into public.inventory (pharmacy_id, drug_id, stock)
    select p.id, d.id, 100
    from public.pharmacies p
    cross join public.drugs d
    where p.owner_id = new.id;
  end if;

  -- Automatically create hospital record if role is hospital
  if (new.raw_user_meta_data->>'role' = 'hospital') then
    insert into public.hospitals (id, name, address, phone)
    values (new.id, new.raw_user_meta_data->>'name', 'Pending Address', 'Pending Phone');
  end if;

  return new;
end;
$$;

-- Create emergency_requests table
-- Create emergency_requests table
create table if not exists emergency_requests (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users, -- can be null for guest SOS?
  customer_name text,
  latitude numeric,
  longitude numeric,
  status text default 'pending', -- pending, dispatched, resolved
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for Emergency Requests
alter table emergency_requests enable row level security;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Emergencies viewable by everyone (demo)" ON emergency_requests;
    CREATE POLICY "Emergencies viewable by everyone (demo)" ON emergency_requests FOR SELECT USING (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Emergencies insertable by everyone" ON emergency_requests;
    CREATE POLICY "Emergencies insertable by everyone" ON emergency_requests FOR INSERT WITH CHECK (true);
END $$;
DO $$ BEGIN
    DROP POLICY IF EXISTS "Emergencies updatable by everyone" ON emergency_requests;
    CREATE POLICY "Emergencies updatable by everyone" ON emergency_requests FOR UPDATE USING (true);
END $$;

-- Admin Approval Columns
alter table public.pharmacies add column if not exists approved boolean default false;
alter table public.hospitals add column if not exists approved boolean default false;

-- Trigger to call the function on signup
-- Trigger to call the function on signup
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
